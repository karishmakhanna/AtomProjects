After loc*l *ssignment: test sp*m?After nonloc*l *ssignment: nonloc*l sp*m After glob*l *ssignment: nonloc*l sp*m In glob*l scope: glob*l sp*m EXPLANATION:?During run time, first the compiler sets up the scope_test() function, then runs the c*ll to scope_test(). In this c*ll to scope_test(), it sets up the do_loc*l(), do_nonloc*l(), *nd do_glob*l() functions, *nd cre*tes * sp*m=“test sp*m” v*ri*ble. When it executes do_loc*l(), * new loc*l sp*m=“loc*l sp*m” is cre*ted th*t does not modify the old one. Thus, the first printing of sp*m in the scope_test() scope is still “test sp*m.” Next, when it executes do_nonloc*l(), the line nonloc*l sp*m cre*tes * sp*m v*ri*ble pointing to the sp*m from scope_test(), which is “test sp*m”. It then ch*nges it to “nonloc*l sp*m.” So, the second printing of sp*m in the scope_test() scope results in “nonloc*l sp*m.” After this, when it executes do_glob*l(), since there is no glob*l sp*m, * new glob*l sp*m is cre*ted *nd set to “glob*l sp*m.” Thus, since this did not modify the existing sp*m in scope_test(), the third printing of it is the s*me *s the second printing of “nonloc*l sp*m.” Fin*lly, the scope_test() function is exited. When the fin*l print sp*m is c*lled, it prints the sp*m th*t w*s cre*ted *t the glob*l level outside the scope of *ll the functions, “glob*l sp*m.” 